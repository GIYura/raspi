#### СОДЕРЖАНИЕ

```
src-01 - пример 'Hello World' для ядра;
src-02 - пример регистрации в ядре устройства;
src-03 - пример функций чтения/записи;
src-04 - пример простого gpio драйвера;
src-05 - пример LCD драйвера;
src-06 - пример LCD драйвера;
src-07 - пример драйвера датчика DS18B20;
src-08 - пример использования таймера;
src-09 - пример чтения температуры с датчика DS18B20 (TODO: перенести в src-07);
src-10 - пример драйвера датчика BMP280 (i2c);
src-11 - пример драйвера датчика BMP280 (spi);
src-12 - использования прерываний на примере gpio дравйвера;
src-13 - пример передачи параметров драйверу;
src-14 - пример успользования ioctl;
src-15 - пример использования потоков в ядре;
src-16 - пример gpio irq (TODO: перенести в src-12);
src-17 - пример gpio irq polling;
src-18 - пример использования очереди в ядре;
src-19 - пример создания записи procfs;
src-20 - пример создания записи sysfs;
src-21 - пример дерева устройств (ч.1);
src-22 - пример дерева устройств (ч.2);
src-25 - пример использования uart loop;
src-26 - пример дерева устройств (ч.3);
```
#### Введение

Для работы с каждым из видов устройств нужна сответствующая подпрограмма в ядре — только она знает, каким образом пользовательские 
данные конвертируются в сигналы шины и наоборот. Такая подпрограмма ядра (оформляемая обычно в виде модуля) называется драйвером. 
В UNIX можно выделить несколько групп устройств (и соответствующих драйверов), основные из них: 
- блочные устройства (блочные, произвольного доступа);
- символьные устройства (символьные, последовательного доступа);
- сетевые устройства (блочные, последовательного доступа, асинхронные). 
Интересная особенность блочных состоит утройств в том, что при обращении к ним может использоваться буфер, в котором кэшируются данные 
последних запросов.

В операционной системе UNIX большинство внешних устройств доступно пользовательским программам в виде специальных файлов.
Эти файлы могут быть, соответственно, двух типов — символьные и блочные. Традиционно, все файлы устройств располагаются в каталоге /dev 
и имеют имена, соответствующие назначению устройства. Например, в операционной системе Linux устройства терминала обозначаются как /dev/tty0,
/dev/tty2 и т.д. с увеличением порядкового номера, жёсткий диск — /dev/hda, а порт PS/2 — /dev/psaux. Названия однотипных устройств обычно 
отличаются целым числом. Программы могут открывать, читать и записывать данные в файлы устройств как в обычные файлы, при этом операционная 
система транслирует пользовательские запросы драйверу соответствующего устройства.

![driver](https://github.com/GIYura/raspi/blob/main/drivers/ldd/driver.png)

Таким образом, файл устройства является одним из интерфейсов взаимодействия процессов с устройствами. Каждый файл устройства имеет два номера — 
старший и младший. По этим номерам операционная система определяет, какой драйвер должен использоваться при обращении к этому файлу.

В операционной системе UNIX большая часть драйверов устройств выполнена в виде модулей ядра. Однако, некоторые драйверы частично выполняются 
в пользовательском режиме (например, видеокарты в рамках графической подсистемы X Windows).

#### Базовые понятия о модулях ядра

Все модули находятся в каталоге /lib/modules/. Модули собираются под определенную версию ядра.

#### Основные команды

- lsmod - посмотреть загруженные модули
- modinfo - информация о модуле
- insmod - загрузить модуль
- rmmod - удалить модуль

Информация о загруженных модулях:

```
cat /proc/modules
```
```
sudo  lsmod | grep [module name]
```
Подробная информация о модуле:

```
modinfo [module nmae]
```

#### Блокирование загрузки модулей

Иногда нужно заблокировать некоторые модули, для этого их можно внести в черный список.
Для этого нужно отредактировать файл:
```
sudo vim /etc/modprobe.d/blacklist.conf 
```
и добавить в конец файла строку:
```
blacklist [module name]
```

#### Автозагрузка модулей

Для добавления модуля при загрузке необходимо снести его в файл:

```
sudo vim /etc/modules-load.d/modules.conf
```
и в конец файла добавить стоку с именем модуля

#### Этапы создания драйвера символьного устройства

1. Регистрация номеров драйвера (majo/minor) при помощи функций: 
```
register_chrdev_region();
alloc_chrdev_region();
```

2. Реализация операций над файлами (open, close, read, write, ioctl, etc)

3. Регистрация драйвера в ядре:
```
cdev_init();
cdev_add();
```

![driver-app](https://github.com/GIYura/raspi/blob/main/drivers/ldd/driver.png)

